/* eslint-disable */
// @generated by protobuf-ts 2.8.2 with parameter add_pb_suffix,eslint_disable,ts_nocheck,keep_enum_prefix,long_type_number
// @generated from protobuf file "reflection/v1/service.proto" (package "reflection.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
//
// Copyright 2016 The gRPC Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// Service exported by server reflection.  A more complete description of how
// server reflection works can be found at
// https://github.com/grpc/grpc/blob/master/doc/server-reflection.md
//
// The canonical version of this proto can be found at
// https://github.com/grpc/grpc-proto/blob/master/grpc/reflection/v1/reflection.proto
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * The message sent by the client when calling GetInfo method.
 *
 * @generated from protobuf message reflection.v1.GetInfoRequest
 */
export interface GetInfoRequest {
    /**
     * @generated from protobuf field: string host = 1;
     */
    host: string;
    /**
     * @generated from protobuf oneof: message_request
     */
    messageRequest: {
        oneofKind: "fileByFilename";
        /**
         * Find a proto file by the file name.
         *
         * @generated from protobuf field: string file_by_filename = 3;
         */
        fileByFilename: string;
    } | {
        oneofKind: "fileContainingSymbol";
        /**
         * Find the proto file that declares the given fully-qualified symbol name.
         * This field should be a fully-qualified symbol name
         * (e.g. <package>.<service>[.<method>] or <package>.<type>).
         *
         * @generated from protobuf field: string file_containing_symbol = 4;
         */
        fileContainingSymbol: string;
    } | {
        oneofKind: "fileContainingExtension";
        /**
         * Find the proto file which defines an extension extending the given
         * message type with the given field number.
         *
         * @generated from protobuf field: reflection.v1.ExtensionRequest file_containing_extension = 5;
         */
        fileContainingExtension: ExtensionRequest;
    } | {
        oneofKind: "allExtensionNumbersOfType";
        /**
         * Finds the tag numbers used by all known extensions of the given message
         * type, and appends them to ExtensionNumberResponse in an undefined order.
         * Its corresponding method is best-effort: it's not guaranteed that the
         * reflection service will implement this method, and it's not guaranteed
         * that this method will provide all extensions. Returns
         * StatusCode::UNIMPLEMENTED if it's not implemented.
         * This field should be a fully-qualified type name. The format is
         * <package>.<type>
         *
         * @generated from protobuf field: string all_extension_numbers_of_type = 6;
         */
        allExtensionNumbersOfType: string;
    } | {
        oneofKind: "listServices";
        /**
         * List the full names of registered services. The content will not be
         * checked.
         *
         * @generated from protobuf field: string list_services = 7;
         */
        listServices: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * The type name and extension number sent by the client when requesting
 * file_containing_extension.
 *
 * @generated from protobuf message reflection.v1.ExtensionRequest
 */
export interface ExtensionRequest {
    /**
     * Fully-qualified type name. The format should be <package>.<type>
     *
     * @generated from protobuf field: string containing_type = 1;
     */
    containingType: string;
    /**
     * @generated from protobuf field: int32 extension_number = 2;
     */
    extensionNumber: number;
}
/**
 * The message sent by the server to answer ServerReflectionInfo method.
 *
 * @generated from protobuf message reflection.v1.GetInfoResponse
 */
export interface GetInfoResponse {
    /**
     * @generated from protobuf field: string valid_host = 1;
     */
    validHost: string;
    /**
     * @generated from protobuf field: reflection.v1.GetInfoRequest original_request = 2;
     */
    originalRequest?: GetInfoRequest;
    /**
     * @generated from protobuf oneof: message_response
     */
    messageResponse: {
        oneofKind: "fileDescriptorResponse";
        /**
         * This message is used to answer file_by_filename, file_containing_symbol,
         * file_containing_extension requests with transitive dependencies.
         * As the repeated label is not allowed in oneof fields, we use a
         * FileDescriptorResponse message to encapsulate the repeated fields.
         * The reflection service is allowed to avoid sending FileDescriptorProtos
         * that were previously sent in response to earlier requests in the stream.
         *
         * @generated from protobuf field: reflection.v1.FileDescriptorResponse file_descriptor_response = 4;
         */
        fileDescriptorResponse: FileDescriptorResponse;
    } | {
        oneofKind: "allExtensionNumbersResponse";
        /**
         * This message is used to answer all_extension_numbers_of_type requests.
         *
         * @generated from protobuf field: reflection.v1.ExtensionNumberResponse all_extension_numbers_response = 5;
         */
        allExtensionNumbersResponse: ExtensionNumberResponse;
    } | {
        oneofKind: "listServicesResponse";
        /**
         * This message is used to answer list_services requests.
         *
         * @generated from protobuf field: reflection.v1.ListServiceResponse list_services_response = 6;
         */
        listServicesResponse: ListServiceResponse;
    } | {
        oneofKind: "errorResponse";
        /**
         * This message is used when an error occurs.
         *
         * @generated from protobuf field: reflection.v1.ErrorResponse error_response = 7;
         */
        errorResponse: ErrorResponse;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Serialized FileDescriptorProto messages sent by the server answering
 * a file_by_filename, file_containing_symbol, or file_containing_extension
 * request.
 *
 * @generated from protobuf message reflection.v1.FileDescriptorResponse
 */
export interface FileDescriptorResponse {
    /**
     * Serialized FileDescriptorProto messages. We avoid taking a dependency on
     * descriptor.proto, which uses proto2 only features, by making them opaque
     * bytes instead.
     *
     * @generated from protobuf field: repeated bytes file_descriptor_proto = 1;
     */
    fileDescriptorProto: Uint8Array[];
}
/**
 * A list of extension numbers sent by the server answering
 * all_extension_numbers_of_type request.
 *
 * @generated from protobuf message reflection.v1.ExtensionNumberResponse
 */
export interface ExtensionNumberResponse {
    /**
     * Full name of the base type, including the package name. The format
     * is <package>.<type>
     *
     * @generated from protobuf field: string base_type_name = 1;
     */
    baseTypeName: string;
    /**
     * @generated from protobuf field: repeated int32 extension_number = 2;
     */
    extensionNumber: number[];
}
/**
 * A list of ServiceResponse sent by the server answering list_services request.
 *
 * @generated from protobuf message reflection.v1.ListServiceResponse
 */
export interface ListServiceResponse {
    /**
     * The information of each service may be expanded in the future, so we use
     * ServiceResponse message to encapsulate it.
     *
     * @generated from protobuf field: repeated reflection.v1.ServiceResponse service = 1;
     */
    service: ServiceResponse[];
}
/**
 * The information of a single service used by ListServiceResponse to answer
 * list_services request.
 *
 * @generated from protobuf message reflection.v1.ServiceResponse
 */
export interface ServiceResponse {
    /**
     * Full name of a registered service, including its package name. The format
     * is <package>.<service>
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * The error code and error message sent by the server when an error occurs.
 *
 * @generated from protobuf message reflection.v1.ErrorResponse
 */
export interface ErrorResponse {
    /**
     * This field uses the error codes defined in grpc::StatusCode.
     *
     * @generated from protobuf field: int32 error_code = 1;
     */
    errorCode: number;
    /**
     * @generated from protobuf field: string error_message = 2;
     */
    errorMessage: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class GetInfoRequest$Type extends MessageType<GetInfoRequest> {
    constructor() {
        super("reflection.v1.GetInfoRequest", [
            { no: 1, name: "host", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "file_by_filename", kind: "scalar", oneof: "messageRequest", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "file_containing_symbol", kind: "scalar", oneof: "messageRequest", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "file_containing_extension", kind: "message", oneof: "messageRequest", T: () => ExtensionRequest },
            { no: 6, name: "all_extension_numbers_of_type", kind: "scalar", oneof: "messageRequest", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "list_services", kind: "scalar", oneof: "messageRequest", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetInfoRequest>): GetInfoRequest {
        const message = { host: "", messageRequest: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInfoRequest): GetInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string host */ 1:
                    message.host = reader.string();
                    break;
                case /* string file_by_filename */ 3:
                    message.messageRequest = {
                        oneofKind: "fileByFilename",
                        fileByFilename: reader.string()
                    };
                    break;
                case /* string file_containing_symbol */ 4:
                    message.messageRequest = {
                        oneofKind: "fileContainingSymbol",
                        fileContainingSymbol: reader.string()
                    };
                    break;
                case /* reflection.v1.ExtensionRequest file_containing_extension */ 5:
                    message.messageRequest = {
                        oneofKind: "fileContainingExtension",
                        fileContainingExtension: ExtensionRequest.internalBinaryRead(reader, reader.uint32(), options, (message.messageRequest as any).fileContainingExtension)
                    };
                    break;
                case /* string all_extension_numbers_of_type */ 6:
                    message.messageRequest = {
                        oneofKind: "allExtensionNumbersOfType",
                        allExtensionNumbersOfType: reader.string()
                    };
                    break;
                case /* string list_services */ 7:
                    message.messageRequest = {
                        oneofKind: "listServices",
                        listServices: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string host = 1; */
        if (message.host !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.host);
        /* string file_by_filename = 3; */
        if (message.messageRequest.oneofKind === "fileByFilename")
            writer.tag(3, WireType.LengthDelimited).string(message.messageRequest.fileByFilename);
        /* string file_containing_symbol = 4; */
        if (message.messageRequest.oneofKind === "fileContainingSymbol")
            writer.tag(4, WireType.LengthDelimited).string(message.messageRequest.fileContainingSymbol);
        /* reflection.v1.ExtensionRequest file_containing_extension = 5; */
        if (message.messageRequest.oneofKind === "fileContainingExtension")
            ExtensionRequest.internalBinaryWrite(message.messageRequest.fileContainingExtension, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string all_extension_numbers_of_type = 6; */
        if (message.messageRequest.oneofKind === "allExtensionNumbersOfType")
            writer.tag(6, WireType.LengthDelimited).string(message.messageRequest.allExtensionNumbersOfType);
        /* string list_services = 7; */
        if (message.messageRequest.oneofKind === "listServices")
            writer.tag(7, WireType.LengthDelimited).string(message.messageRequest.listServices);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message reflection.v1.GetInfoRequest
 */
export const GetInfoRequest = new GetInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtensionRequest$Type extends MessageType<ExtensionRequest> {
    constructor() {
        super("reflection.v1.ExtensionRequest", [
            { no: 1, name: "containing_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "extension_number", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ExtensionRequest>): ExtensionRequest {
        const message = { containingType: "", extensionNumber: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExtensionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtensionRequest): ExtensionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string containing_type */ 1:
                    message.containingType = reader.string();
                    break;
                case /* int32 extension_number */ 2:
                    message.extensionNumber = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtensionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string containing_type = 1; */
        if (message.containingType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.containingType);
        /* int32 extension_number = 2; */
        if (message.extensionNumber !== 0)
            writer.tag(2, WireType.Varint).int32(message.extensionNumber);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message reflection.v1.ExtensionRequest
 */
export const ExtensionRequest = new ExtensionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetInfoResponse$Type extends MessageType<GetInfoResponse> {
    constructor() {
        super("reflection.v1.GetInfoResponse", [
            { no: 1, name: "valid_host", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "original_request", kind: "message", T: () => GetInfoRequest },
            { no: 4, name: "file_descriptor_response", kind: "message", oneof: "messageResponse", T: () => FileDescriptorResponse },
            { no: 5, name: "all_extension_numbers_response", kind: "message", oneof: "messageResponse", T: () => ExtensionNumberResponse },
            { no: 6, name: "list_services_response", kind: "message", oneof: "messageResponse", T: () => ListServiceResponse },
            { no: 7, name: "error_response", kind: "message", oneof: "messageResponse", T: () => ErrorResponse }
        ]);
    }
    create(value?: PartialMessage<GetInfoResponse>): GetInfoResponse {
        const message = { validHost: "", messageResponse: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInfoResponse): GetInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string valid_host */ 1:
                    message.validHost = reader.string();
                    break;
                case /* reflection.v1.GetInfoRequest original_request */ 2:
                    message.originalRequest = GetInfoRequest.internalBinaryRead(reader, reader.uint32(), options, message.originalRequest);
                    break;
                case /* reflection.v1.FileDescriptorResponse file_descriptor_response */ 4:
                    message.messageResponse = {
                        oneofKind: "fileDescriptorResponse",
                        fileDescriptorResponse: FileDescriptorResponse.internalBinaryRead(reader, reader.uint32(), options, (message.messageResponse as any).fileDescriptorResponse)
                    };
                    break;
                case /* reflection.v1.ExtensionNumberResponse all_extension_numbers_response */ 5:
                    message.messageResponse = {
                        oneofKind: "allExtensionNumbersResponse",
                        allExtensionNumbersResponse: ExtensionNumberResponse.internalBinaryRead(reader, reader.uint32(), options, (message.messageResponse as any).allExtensionNumbersResponse)
                    };
                    break;
                case /* reflection.v1.ListServiceResponse list_services_response */ 6:
                    message.messageResponse = {
                        oneofKind: "listServicesResponse",
                        listServicesResponse: ListServiceResponse.internalBinaryRead(reader, reader.uint32(), options, (message.messageResponse as any).listServicesResponse)
                    };
                    break;
                case /* reflection.v1.ErrorResponse error_response */ 7:
                    message.messageResponse = {
                        oneofKind: "errorResponse",
                        errorResponse: ErrorResponse.internalBinaryRead(reader, reader.uint32(), options, (message.messageResponse as any).errorResponse)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string valid_host = 1; */
        if (message.validHost !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.validHost);
        /* reflection.v1.GetInfoRequest original_request = 2; */
        if (message.originalRequest)
            GetInfoRequest.internalBinaryWrite(message.originalRequest, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* reflection.v1.FileDescriptorResponse file_descriptor_response = 4; */
        if (message.messageResponse.oneofKind === "fileDescriptorResponse")
            FileDescriptorResponse.internalBinaryWrite(message.messageResponse.fileDescriptorResponse, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* reflection.v1.ExtensionNumberResponse all_extension_numbers_response = 5; */
        if (message.messageResponse.oneofKind === "allExtensionNumbersResponse")
            ExtensionNumberResponse.internalBinaryWrite(message.messageResponse.allExtensionNumbersResponse, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* reflection.v1.ListServiceResponse list_services_response = 6; */
        if (message.messageResponse.oneofKind === "listServicesResponse")
            ListServiceResponse.internalBinaryWrite(message.messageResponse.listServicesResponse, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* reflection.v1.ErrorResponse error_response = 7; */
        if (message.messageResponse.oneofKind === "errorResponse")
            ErrorResponse.internalBinaryWrite(message.messageResponse.errorResponse, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message reflection.v1.GetInfoResponse
 */
export const GetInfoResponse = new GetInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileDescriptorResponse$Type extends MessageType<FileDescriptorResponse> {
    constructor() {
        super("reflection.v1.FileDescriptorResponse", [
            { no: 1, name: "file_descriptor_proto", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<FileDescriptorResponse>): FileDescriptorResponse {
        const message = { fileDescriptorProto: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FileDescriptorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileDescriptorResponse): FileDescriptorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes file_descriptor_proto */ 1:
                    message.fileDescriptorProto.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileDescriptorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes file_descriptor_proto = 1; */
        for (let i = 0; i < message.fileDescriptorProto.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.fileDescriptorProto[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message reflection.v1.FileDescriptorResponse
 */
export const FileDescriptorResponse = new FileDescriptorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtensionNumberResponse$Type extends MessageType<ExtensionNumberResponse> {
    constructor() {
        super("reflection.v1.ExtensionNumberResponse", [
            { no: 1, name: "base_type_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "extension_number", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ExtensionNumberResponse>): ExtensionNumberResponse {
        const message = { baseTypeName: "", extensionNumber: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExtensionNumberResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtensionNumberResponse): ExtensionNumberResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string base_type_name */ 1:
                    message.baseTypeName = reader.string();
                    break;
                case /* repeated int32 extension_number */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.extensionNumber.push(reader.int32());
                    else
                        message.extensionNumber.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtensionNumberResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string base_type_name = 1; */
        if (message.baseTypeName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.baseTypeName);
        /* repeated int32 extension_number = 2; */
        if (message.extensionNumber.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.extensionNumber.length; i++)
                writer.int32(message.extensionNumber[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message reflection.v1.ExtensionNumberResponse
 */
export const ExtensionNumberResponse = new ExtensionNumberResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListServiceResponse$Type extends MessageType<ListServiceResponse> {
    constructor() {
        super("reflection.v1.ListServiceResponse", [
            { no: 1, name: "service", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ServiceResponse }
        ]);
    }
    create(value?: PartialMessage<ListServiceResponse>): ListServiceResponse {
        const message = { service: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListServiceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListServiceResponse): ListServiceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated reflection.v1.ServiceResponse service */ 1:
                    message.service.push(ServiceResponse.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListServiceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated reflection.v1.ServiceResponse service = 1; */
        for (let i = 0; i < message.service.length; i++)
            ServiceResponse.internalBinaryWrite(message.service[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message reflection.v1.ListServiceResponse
 */
export const ListServiceResponse = new ListServiceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceResponse$Type extends MessageType<ServiceResponse> {
    constructor() {
        super("reflection.v1.ServiceResponse", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ServiceResponse>): ServiceResponse {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServiceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceResponse): ServiceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message reflection.v1.ServiceResponse
 */
export const ServiceResponse = new ServiceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ErrorResponse$Type extends MessageType<ErrorResponse> {
    constructor() {
        super("reflection.v1.ErrorResponse", [
            { no: 1, name: "error_code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "error_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ErrorResponse>): ErrorResponse {
        const message = { errorCode: 0, errorMessage: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ErrorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ErrorResponse): ErrorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 error_code */ 1:
                    message.errorCode = reader.int32();
                    break;
                case /* string error_message */ 2:
                    message.errorMessage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ErrorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 error_code = 1; */
        if (message.errorCode !== 0)
            writer.tag(1, WireType.Varint).int32(message.errorCode);
        /* string error_message = 2; */
        if (message.errorMessage !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.errorMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message reflection.v1.ErrorResponse
 */
export const ErrorResponse = new ErrorResponse$Type();
/**
 * @generated ServiceType for protobuf service reflection.v1.ReflectionService
 */
export const ReflectionService = new ServiceType("reflection.v1.ReflectionService", [
    { name: "GetInfo", serverStreaming: true, clientStreaming: true, options: { "google.api.http": { get: "/v1/info" } }, I: GetInfoRequest, O: GetInfoResponse }
]);
